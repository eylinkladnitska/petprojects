
### **Сценарий 1: Регистрация Фрилансера с Двухфакторной Аутентификацией**

**Цель:** Пользователь регистрируется как фрилансер, его данные сохраняются, и он активирует 2FA (например, через SMS), получая подтверждение.

**Участвующие сервисы:**

*   Frontend Application
*   API Gateway
*   Authentication & Authorization Service (Auth Service)
*   User & Profile Service
*   Roles & Permissions Service
*   Notification Service
*   RabbitMQ (Message Broker)

**Описание потока сообщений:**

1.  **Фрилансер (Пользователь) -> Frontend Application**
    *   **Действие:** Пользователь заполняет форму регистрации (email, пароль, подтверждение пароля, имя, страна) и выбирает тип профиля "Фрилансер".
    *   **Payload:** Вводятся данные в поля формы.
    *   **Примечания:** Не является сетевым запросом к бэкенду, это взаимодействие пользователя с UI.

2.  **Frontend Application -> API Gateway (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /api/v1/auth/register`
    *   **Payload:**
        ```json
        {
          "email": "new.freelancer@example.com",
          "password": "SecurePassword123",
          "confirmPassword": "SecurePassword123",
          "firstName": "Anna",
          "lastName": "Smirnova",
          "country": "Russia",
          "profileType": "FREELANCER"
        }
        ```
    *   **Примечания:** Frontend не знает о микросервисах, он отправляет запрос на единый endpoint API Gateway.

3.  **API Gateway -> Auth Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /auth/register` (API Gateway перенаправляет запрос)
    *   **Payload:** То же, что и из Frontend.
    *   **Response (Auth Service -> API Gateway):**
        ```json
        {
          "status": "success",
          "message": "User registered successfully, email confirmation sent.",
          "userId": "uuid-of-new-user",
          "accessToken": "jwt-token-string", // Для первой авторизации без подтверждения 2FA
          "emailConfirmed": false,
          "2faEnabled": false
        }
        ```
    *   **Примечания:** Auth Service выполняет валидацию данных, хеширование пароля, сохраняет базовую учетную запись. Генерирует JWT для дальнейшей работы.

4.  **Auth Service -> Roles & Permissions Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /roles/assign-default`
    *   **Payload:**
        ```json
        {
          "userId": "uuid-of-new-user",
          "profileType": "FREELANCER"
        }
        ```
    *   **Response (Roles & Permissions Service -> Auth Service):**
        ```json
        {
          "status": "success",
          "message": "Default role assigned."
        }
        ```
    *   **Примечания:** Auth Service запрашивает у Roles Service присвоение новой учетной записи стандартной роли "Фрилансер".

5.  **Auth Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `UserRegisteredEvent`
    *   **Payload:**
        ```json
        {
          "userId": "uuid-of-new-user",
          "email": "new.freelancer@example.com",
          "firstName": "Anna",
          "profileType": "FREELANCER",
          "registrationTimestamp": "2025-06-28T10:30:00Z"
        }
        ```
    *   **Примечания:** Auth Service публикует событие о новой регистрации. На это событие могут подписаться User & Profile Service (для создания детального профиля), Notification Service (для отправки подтверждения email) и Analytics Service (для метрик).

6.  **RabbitMQ -> User & Profile Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `UserRegisteredEvent`
    *   **Payload:** То же, что в п. 5.
    *   **Действие User & Profile Service:** Создает запись о профиле фрилансера с базовыми данными, полученными из события. Поля портфолио, навыки остаются пустыми до заполнения пользователем.

7.  **RabbitMQ -> Notification Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `UserRegisteredEvent`
    *   **Payload:** То же, что в п. 5.
    *   **Действие Notification Service:** Генерирует и отправляет письмо для подтверждения email.
        *   *(Внутреннее взаимодействие Notification Service):* Возможно, `Notification Service` сделает `REST API: GET /users/{userId}` запрос к `User & Profile Service` для получения дополнительных данных о пользователе для персонализации письма, если их нет в событии.
    *   **Ожидаемый результат для пользователя:** Пользователь получает письмо для подтверждения email.

---

**Теперь активируем 2FA (после успешной регистрации):**

8.  **Frontend Application -> API Gateway (Тип взаимодействия: REST API)**
    *   **Действие:** Пользователь в настройках профиля (уже войдя в систему с первым JWT) включает 2FA и выбирает SMS-подтверждение.
    *   **Метод:** `POST /api/v1/auth/2fa/enable`
    *   **Headers:** `Authorization: Bearer jwt-token-string`
    *   **Payload:**
        ```json
        {
          "method": "SMS",
          "phoneNumber": "+79991234567"
        }
        ```
    *   **Примечания:** Предполагаем, что номер телефона уже связан с профилем или указывается здесь.

9.  **API Gateway -> Auth Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /auth/2fa/enable`
    *   **Payload:** То же, что из Frontend.
    *   **Response (Auth Service -> API Gateway):**
        ```json
        {
          "status": "pending_confirmation",
          "message": "SMS code sent to your phone."
        }
        ```
    *   **Примечания:** Auth Service генерирует код, сохраняет его привязку к сессии, отправляет запрос на отправку SMS.

10. **Auth Service -> Notification Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /notification/send-sms`
    *   **Payload:**
        ```json
        {
          "userId": "uuid-of-new-user",
          "phoneNumber": "+79991234567",
          "message": "Your 2FA code: 123456" // Код генерируется в Auth Service
        }
        ```
    *   **Response (Notification Service -> Auth Service):**
        ```json
        {
          "status": "sent",
          "notificationId": "uuid-of-sms-job"
        }
        ```
    *   **Примечания:** Auth Service делегирует отправку SMS Notification Service.

11. **Frontend Application -> API Gateway (Тип взаимодействия: REST API)**
    *   **Действие:** Пользователь вводит полученный SMS-код в форме подтверждения 2FA.
    *   **Метод:** `POST /api/v1/auth/2fa/confirm`
    *   **Headers:** `Authorization: Bearer jwt-token-string`
    *   **Payload:**
        ```json
        {
          "code": "123456"
        }
        ```

12. **API Gateway -> Auth Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /auth/2fa/confirm`
    *   **Payload:** То же, что из Frontend.
    *   **Response (Auth Service -> API Gateway):**
        ```json
        {
          "status": "success",
          "message": "2FA successfully enabled.",
          "2faEnabled": true,
          "accessToken": "new-jwt-token-string" // Обновленный токен, т.к. статус 2FA изменился
        }
        ```
    *   **Примечания:** Auth Service проверяет код, если верен, обновляет статус 2FA для пользователя. Выдает новый JWT.

13. **Auth Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `User2FAEnabledEvent`
    *   **Payload:**
        ```json
        {
          "userId": "uuid-of-new-user",
          "method": "SMS",
          "timestamp": "2025-06-28T10:35:00Z"
        }
        ```
    *   **Примечания:** Публикуется для Analytics Service или других заинтересованных сторон, которым нужно знать об активации 2FA.



### **Сценарий 2: Размещение Заказчиком Нового Заказа**

**Цель:** Заказчик создает новый проект, оплачивает фиксированную сумму за размещение, и заказ публикуется в каталоге.

**Участвующие сервисы:**

*   Frontend Application
*   API Gateway
*   Order & Project Service
*   Payment Service
*   Notification Service
*   RabbitMQ (Message Broker)
*   User & Profile Service (для получения данных профиля Заказчика)
*   Analytics & Reporting Service

**Описание потока сообщений:**

1.  **Заказчик (Пользователь) -> Frontend Application**
    *   **Действие:** Заказчик, войдя в систему, заполняет форму создания нового заказа (описание, сроки, бюджет, теги).
    *   **Payload:** Введенные данные.
    *   **Примечания:** Взаимодействие пользователя с UI.

2.  **Frontend Application -> API Gateway (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /api/v1/orders/create`
    *   **Headers:** `Authorization: Bearer jwt-token-string` (токен заказчика)
    *   **Payload:**
        ```json
        {
          "title": "Разработка адаптивного лендинга",
          "description": "Нужен лендинг для нового продукта...",
          "budget": {
            "amount": 50000,
            "currency": "RUB"
          },
          "deadline": "2025-07-28T23:59:59Z",
          "technologies": ["React", "Node.js", "Figma"],
          "styles": ["Modern", "Minimalistic"]
        }
        ```
    *   **Примечания:** Запрос на создание заказа.

3.  **API Gateway -> Order & Project Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /orders/create`
    *   **Payload:** То же, что из Frontend, плюс `userId` из JWT-токена.
    *   **Response (Order & Project Service -> API Gateway):**
        ```json
        {
          "status": "pending_payment",
          "message": "Order created, awaiting payment for publication.",
          "orderId": "uuid-of-new-order",
          "publicationFee": {
            "amount": 500,
            "currency": "RUB"
          }
        }
        ```
    *   **Примечания:** Order & Project Service сохраняет заказ со статусом `pending_payment` и возвращает информацию о требуемой плате за публикацию.

4.  **Frontend Application -> API Gateway (Тип взаимодействия: REST API)**
    *   **Действие:** Frontend получает информацию о плате за публикацию и инициирует её. (Предполагаем, что у Заказчика уже пополнен счет в системе, т.к. MVP не включает внешние платежные системы).
    *   **Метод:** `POST /api/v1/payments/debit-publication-fee`
    *   **Headers:** `Authorization: Bearer jwt-token-string`
    *   **Payload:**
        ```json
        {
          "userId": "uuid-of-customer",
          "orderId": "uuid-of-new-order",
          "amount": {
            "amount": 500,
            "currency": "RUB"
          },
          "description": "Publication fee for order 'Разработка адаптивного лендинга'"
        }
        ```
    *   **Примечания:** Запрос на списание средств за публикацию заказа.

5.  **API Gateway -> Payment Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /payments/debit-publication-fee`
    *   **Payload:** То же, что из Frontend.
    *   **Response (Payment Service -> API Gateway):**
        ```json
        {
          "status": "success",
          "message": "Publication fee debited successfully.",
          "transactionId": "uuid-of-transaction",
          "newBalance": {
            "amount": 49500,
            "currency": "RUB"
          }
        }
        ```
    *   **Примечания:** Payment Service имитирует списание средств со счета заказчика. Если средств недостаточно, возвращает ошибку.

6.  **Payment Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `OrderPublicationFeeDebitedEvent`
    *   **Payload:**
        ```json
        {
          "userId": "uuid-of-customer",
          "orderId": "uuid-of-new-order",
          "amount": {
            "amount": 500,
            "currency": "RUB"
          },
          "transactionId": "uuid-of-transaction",
          "timestamp": "2025-06-28T10:45:00Z"
        }
        ```
    *   **Примечания:** Payment Service публикует событие об успешном списании средств за публикацию.

7.  **RabbitMQ -> Order & Project Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `OrderPublicationFeeDebitedEvent`
    *   **Payload:** То же, что в п. 6.
    *   **Действие Order & Project Service:** Изменяет статус заказа с `pending_payment` на `published` (или `active`).

8.  **RabbitMQ -> Notification Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `OrderPublicationFeeDebitedEvent`
    *   **Payload:** То же, что в п. 6.
    *   **Действие Notification Service:** Отправляет уведомление заказчику об успешном размещении заказа.
        *   *(Внутреннее взаимодействие Notification Service):* Может запросить `REST API: GET /orders/{orderId}` к `Order & Project Service` для получения названия заказа.

9.  **RabbitMQ -> Analytics & Reporting Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `OrderPublicationFeeDebitedEvent` (или `OrderPublishedEvent`, если Order & Project Service тоже публикует событие после смены статуса)
    *   **Payload:** Информация о заказе и оплате.
    *   **Действие Analytics & Reporting Service:** Записывает метрику о количестве размещенных заказов и полученных комиссиях.

10. **Order & Project Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `OrderPublishedEvent`
    *   **Payload:**
        ```json
        {
          "orderId": "uuid-of-new-order",
          "title": "Разработка адаптивного лендинга",
          "customerId": "uuid-of-customer",
          "status": "active",
          "publicationTimestamp": "2025-06-28T10:46:00Z"
        }
        ```
    *   **Примечания:** Order & Project Service публикует событие о публикации заказа, чтобы заинтересованные сервисы (например, Notification Service для фрилансеров, Analytics Service) могли об этом узнать.


### **Сценарий 3: Обмен Сообщениями в Заказе**

**Цель:** Фрилансер и Заказчик обмениваются текстовыми сообщениями и прикрепляют файлы в рамках конкретного активного заказа.

**Участвующие сервисы:**

*   Frontend Application
*   API Gateway
*   Messenger Service
*   Notification Service
*   Order & Project Service (для проверки контекста заказа)
*   User & Profile Service (для получения данных отправителя/получателя)
*   Support & Dispute Service (для доступа к истории чата в случае спора)
*   RabbitMQ (Message Broker)

**Описание потока сообщений:**

1.  **Отправитель (Фрилансер/Заказчик) -> Frontend Application**
    *   **Действие:** Пользователь (Фрилансер или Заказчик) в интерфейсе активного заказа набирает сообщение и/или прикрепляет файл, затем отправляет его.
    *   **Payload:** Текст сообщения, возможно, данные файла.
    *   **Примечания:** Взаимодействие пользователя с UI.

2.  **Frontend Application -> API Gateway (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /api/v1/messages/send`
    *   **Headers:** `Authorization: Bearer jwt-token-string` (токен отправителя)
    *   **Payload:**
        ```json
        {
          "orderId": "uuid-of-active-order",
          "senderId": "uuid-of-sender-user", // Извлекается из JWT
          "recipientId": "uuid-of-recipient-user", // Определяется Messenger Service на основе orderId
          "text": "Здравствуйте, вот первая версия макета.",
          "attachments": [
            {
              "fileName": "mockup_v1.png",
              "fileSize": 1234567,
              "fileUrl": "url-to-uploaded-file-storage" // Предполагаем, что файлы загружаются отдельно в облачное хранилище
            }
          ]
        }
        ```
    *   **Примечания:** Frontend отправляет запрос на отправку сообщения.

3.  **API Gateway -> Messenger Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /messages/send`
    *   **Payload:** То же, что из Frontend, с дополнительными метаданными из токена.
    *   **Внутреннее взаимодействие Messenger Service:**
        *   `Messenger Service` может сделать `REST API: GET /orders/{orderId}/participants` к `Order & Project Service` для подтверждения, что отправитель и предполагаемый получатель являются участниками данного заказа.
        *   `Messenger Service` может сделать `REST API: GET /users/{userId}` запросы к `User & Profile Service` для получения отображаемых имен отправителя/получателя.
    *   **Response (Messenger Service -> API Gateway):**
        ```json
        {
          "status": "sent",
          "messageId": "uuid-of-new-message",
          "timestamp": "2025-06-28T11:00:00Z"
        }
        ```
    *   **Примечания:** Messenger Service сохраняет сообщение в своей базе данных, помечает его как отправленное.

4.  **Messenger Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `NewMessageEvent`
    *   **Payload:**
        ```json
        {
          "messageId": "uuid-of-new-message",
          "orderId": "uuid-of-active-order",
          "senderId": "uuid-of-sender-user",
          "recipientId": "uuid-of-recipient-user",
          "textPreview": "Здравствуйте, вот...", // Краткое превью текста для уведомлений
          "hasAttachments": true,
          "timestamp": "2025-06-28T11:00:00Z"
        }
        ```
    *   **Примечания:** Messenger Service публикует событие о новом сообщении.

5.  **RabbitMQ -> Notification Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `NewMessageEvent`
    *   **Payload:** То же, что в п. 4.
    *   **Действие Notification Service:** Определяет, является ли получатель онлайн. Если нет, отправляет email или push-уведомление (если мобильные будут в будущем) о новом сообщении.
        *   *(Внутреннее взаимодействие Notification Service):* Может запросить `REST API: GET /users/{userId}` к `User & Profile Service` для получения email получателя.

6.  **(Опционально) RabbitMQ -> Analytics & Reporting Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `NewMessageEvent`
    *   **Payload:** То же, что в п. 4.
    *   **Действие Analytics & Reporting Service:** Регистрирует активность по обмену сообщениями для метрик "количество сообщений", "активность пользователей".

7.  **Получатель (Фрилансер/Заказчик) -> Frontend Application**
    *   **Действие:** Frontend Приложения получателя (если он онлайн) через WebSocket (или долгое HTTP-соединение, что будет деталью реализации) получает уведомление о новом сообщении и подгружает его в чат.
    *   **Взаимодействие Frontend с Messenger Service:** `Frontend Application` может периодически запрашивать `GET /api/v1/messages/order/{orderId}?last_message_id=...` для получения новых сообщений (через API Gateway -> Messenger Service).
    *   **Ожидаемый результат для получателя:** Сообщение мгновенно появляется в чате.


### **Сценарий 4: Завершение Заказа и Выплата**

**Цель:** Заказчик принимает выполненную работу, система списывает средства со счета Заказчика, начисляет оплату Фрилансеру (с учетом комиссии и опциональной премии), и обе стороны могут оставить отзывы.

**Участвующие сервисы:**

*   Frontend Application
*   API Gateway
*   Order & Project Service
*   Payment Service
*   Notification Service
*   User & Profile Service (для работы с отзывами и данными пользователей)
*   Analytics & Reporting Service
*   RabbitMQ (Message Broker)

**Описание потока сообщений:**

1.  **Фрилансер -> Frontend Application**
    *   **Действие:** Фрилансер в интерфейсе заказа помечает работу как "Завершено" и загружает финальные результаты (например, ссылку на репозиторий, архив).
    *   **Payload:** Соответствующие данные и ссылки.
    *   **Примечания:** UI-взаимодействие.

2.  **Frontend Application -> API Gateway (Тип взаимодействия: REST API)**
    *   **Метод:** `PUT /api/v1/orders/{orderId}/mark-as-completed`
    *   **Headers:** `Authorization: Bearer jwt-token-string` (токен фрилансера)
    *   **Payload:**
        ```json
        {
          "finalResultsUrl": "https://repo.example.com/project_final.zip",
          "notes": "Финальные файлы проекта, готовы к приемке."
        }
        ```
    *   **Примечания:** Запрос на изменение статуса заказа.

3.  **API Gateway -> Order & Project Service (Тип взаимодействия: REST API)**
    *   **Метод:** `PUT /orders/{orderId}/mark-as-completed`
    *   **Payload:** То же, что из Frontend, плюс `userId` из токена.
    *   **Response (Order & Project Service -> API Gateway):**
        ```json
        {
          "status": "pending_acceptance",
          "message": "Order marked as completed, awaiting customer acceptance."
        }
        ```
    *   **Примечания:** Order & Project Service меняет статус заказа на `pending_acceptance`.

4.  **Order & Project Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `OrderCompletedByFreelancerEvent`
    *   **Payload:**
        ```json
        {
          "orderId": "uuid-of-order",
          "freelancerId": "uuid-of-freelancer",
          "customerId": "uuid-of-customer",
          "status": "pending_acceptance",
          "timestamp": "2025-06-28T11:30:00Z"
        }
        ```
    *   **Примечания:** Уведомляет заинтересованные сервисы.

5.  **RabbitMQ -> Notification Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `OrderCompletedByFreelancerEvent`
    *   **Payload:** То же, что в п. 4.
    *   **Действие Notification Service:** Отправляет уведомление Заказчику о том, что работа завершена и готова к приемке.

---

**Теперь Заказчик принимает работу и осуществляет выплату:**

6.  **Заказчик -> Frontend Application**
    *   **Действие:** Заказчик просматривает результаты, принимает решение о приемке. В интерфейсе подтверждения может указать премию.
    *   **Payload:** Вводятся данные в форму.

7.  **Frontend Application -> API Gateway (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /api/v1/orders/{orderId}/accept-and-payout`
    *   **Headers:** `Authorization: Bearer jwt-token-string` (токен заказчика)
    *   **Payload:**
        ```json
        {
          "orderId": "uuid-of-order",
          "customerId": "uuid-of-customer", // Извлекается из JWT
          "freelancerId": "uuid-of-freelancer", // Определяется из данных заказа
          "acceptWork": true,
          "payoutAmount": {
            "amount": 50000,
            "currency": "RUB"
          },
          "bonusAmount": { // Опциональная премия
            "amount": 5000,
            "currency": "RUB"
          },
          "customerRating": 5,
          "customerReview": "Отличная работа, все в срок и по ТЗ!"
        }
        ```
    *   **Примечания:** Запрос на приемку работы, инициирование выплаты и оставление отзыва.

8.  **API Gateway -> Order & Project Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /orders/{orderId}/accept-and-payout`
    *   **Payload:** То же, что из Frontend.
    *   **Внутреннее взаимодействие Order & Project Service:**
        *   Проверяет статус заказа.
        *   Получает комиссию платформы (возможно, фиксированную или процент, хранящуюся в `Admin Service` через `REST API: GET /admin/settings/commission`).
    *   **Response (Order & Project Service -> API Gateway):**
        ```json
        {
          "status": "payout_pending",
          "message": "Work accepted, payment processing initiated."
        }
        ```
    *   **Примечания:** Order & Project Service меняет статус заказа на `payout_pending` и готовит данные для Payment Service.

9.  **Order & Project Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `OrderAcceptedForPayoutEvent`
    *   **Payload:**
        ```json
        {
          "orderId": "uuid-of-order",
          "freelancerId": "uuid-of-freelancer",
          "customerId": "uuid-of-customer",
          "baseAmount": { "amount": 50000, "currency": "RUB" }, // Основная сумма
          "bonusAmount": { "amount": 5000, "currency": "RUB" }, // Премия
          "platformCommissionAmount": { "amount": 5000, "currency": "RUB" }, // Рассчитанная комиссия
          "timestamp": "2025-06-28T11:40:00Z"
        }
        ```
    *   **Примечания:** Order & Project Service публикует событие для Payment Service и Analytics Service.

---

**Теперь происходит финансовая часть:**

10. **RabbitMQ -> Payment Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `OrderAcceptedForPayoutEvent`
    *   **Payload:** То же, что в п. 9.
    *   **Действие Payment Service:**
        *   Списывает общую сумму заказа (`baseAmount` + `bonusAmount`) со счета Заказчика.
        *   Начисляет (`baseAmount` - `platformCommissionAmount` + `bonusAmount`) на счет Фрилансера.
        *   Записывает детали комиссии.
    *   **Payment Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
        *   **Событие:** `PaymentProcessedEvent` (публикуется после успешного завершения всех финансовых операций)
        *   **Payload:**
            ```json
            {
              "orderId": "uuid-of-order",
              "customerId": "uuid-of-customer",
              "freelancerId": "uuid-of-freelancer",
              "totalDebited": { "amount": 55000, "currency": "RUB" },
              "totalCreditedToFreelancer": { "amount": 50000, "currency": "RUB" },
              "platformCommission": { "amount": 5000, "currency": "RUB" },
              "status": "completed",
              "transactionTimestamp": "2025-06-28T11:45:00Z"
            }
            ```

---

**Завершающие действия после выплаты и отзывы:**

11. **RabbitMQ -> Order & Project Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `PaymentProcessedEvent`
    *   **Payload:** То же, что в п. 10.
    *   **Действие Order & Project Service:** Изменяет статус заказа на `completed`.

12. **Order & Project Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `OrderFullyCompletedEvent`
    *   **Payload:**
        ```json
        {
          "orderId": "uuid-of-order",
          "status": "completed",
          "completionTimestamp": "2025-06-28T11:46:00Z"
        }
        ```
    *   **Примечания:** Уведомляет всех, что заказ окончательно завершен.

13. **RabbitMQ -> Notification Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `PaymentProcessedEvent` и/или `OrderFullyCompletedEvent`
    *   **Payload:** Соответствующие данные.
    *   **Действие Notification Service:** Отправляет уведомление Фрилансеру о зачислении средств и Заказчику об успешном завершении транзакции.

14. **RabbitMQ -> Analytics & Reporting Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `PaymentProcessedEvent` и/или `OrderFullyCompletedEvent`
    *   **Payload:** Соответствующие данные.
    *   **Действие Analytics & Reporting Service:** Обновляет метрики по успешным заказам, выручке, выплатам, премиям.

15. **Order & Project Service -> User & Profile Service (Тип взаимодействия: REST API)** - *Если отзыв был отправлен вместе с приемкой*
    *   **Метод:** `POST /users/add-review`
    *   **Payload:**
        ```json
        {
          "reviewerId": "uuid-of-customer",
          "reviewedId": "uuid-of-freelancer",
          "orderId": "uuid-of-order",
          "rating": 5,
          "reviewText": "Отличная работа, все в срок и по ТЗ!"
        }
        ```
    *   **Response (User & Profile Service -> Order & Project Service):**
        ```json
        {
          "status": "success",
          "reviewId": "uuid-of-review"
        }
        ```
    *   **Примечания:** User & Profile Service сохраняет отзыв, обновляет рейтинг пользователя.

16. **User & Profile Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `UserReviewAddedEvent`
    *   **Payload:**
        ```json
        {
          "reviewId": "uuid-of-review",
          "reviewerId": "uuid-of-customer",
          "reviewedId": "uuid-of-freelancer",
          "orderId": "uuid-of-order",
          "rating": 5,
          "timestamp": "2025-06-28T11:47:00Z"
        }
        ```
    *   **Примечания:** Уведомляет Analytics Service о новом отзыве.

17. **Фрилансер -> Frontend Application (Действие после завершения)**
    *   **Действие:** Фрилансер оставляет свой отзыв о Заказчике. Этот поток будет аналогичен пп. 7-10, нонициируется Фрилансером.


### **Сценарий 5: Подача Обращения в Техподдержку и Эскалация**

**Цель:** Пользователь подает обращение в службу поддержки. В случае неудовлетворенности ответом, обращение перенаправляется, а затем эскалируется администратору.

**Участвующие сервисы:**

*   Frontend Application
*   API Gateway
*   Support & Dispute Service
*   Notification Service
*   Admin Service
*   User & Profile Service (для контекста пользователя)
*   Order & Project Service (для контекста заказа)
*   Messenger Service (для истории чата)
*   RabbitMQ (Message Broker)

**Описание потока сообщений:**

1.  **Пользователь (Фрилансер/Заказчик) -> Frontend Application**
    *   **Действие:** Пользователь, войдя в систему, переходит в раздел поддержки и заполняет форму обращения (тема, описание проблемы, возможно, ID заказа).
    *   **Payload:** Вводятся данные в форму.
    *   **Примечания:** UI-взаимодействие.

2.  **Frontend Application -> API Gateway (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /api/v1/support/tickets/create`
    *   **Headers:** `Authorization: Bearer jwt-token-string` (токен пользователя)
    *   **Payload:**
        ```json
        {
          "subject": "Проблема с оплатой заказа #123",
          "description": "После завершения заказа средства не поступили на мой счет...",
          "relatedOrderId": "uuid-of-order", // Опционально
          "attachments": [] // Опционально
        }
        ```
    *   **Примечания:** Запрос на создание нового обращения.

3.  **API Gateway -> Support & Dispute Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /support/tickets/create`
    *   **Payload:** То же, что из Frontend, плюс `userId` из JWT-токена.
    *   **Response (Support & Dispute Service -> API Gateway):**
        ```json
        {
          "status": "created",
          "ticketId": "uuid-of-new-ticket",
          "message": "Ваше обращение принято, ожидайте ответа."
        }
        ```
    *   **Примечания:** Support & Dispute Service сохраняет обращение, присваивает ему статус "Новое" и назначает (или ставит в очередь) первому свободному сотруднику поддержки.

4.  **Support & Dispute Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `TicketCreatedEvent`
    *   **Payload:**
        ```json
        {
          "ticketId": "uuid-of-new-ticket",
          "userId": "uuid-of-user",
          "subject": "Проблема с оплатой...",
          "status": "new",
          "timestamp": "2025-06-28T12:00:00Z"
        }
        ```
    *   **Примечания:** Уведомляет Notification Service, а также Analytics & Reporting Service о новом обращении.

5.  **RabbitMQ -> Notification Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `TicketCreatedEvent`
    *   **Payload:** То же, что в п. 4.
    *   **Действие Notification Service:** Отправляет пользователю email или внутреннее уведомление о приёме обращения.

6.  **Сотрудник службы поддержки -> Frontend Application (Админ-панель)**
    *   **Действие:** Сотрудник поддержки видит новое обращение в своей очереди, назначает его на себя, изучает контекст.
    *   **Взаимодействия Support Service (через API Gateway):**
        *   `Support & Dispute Service` может запросить `REST API: GET /users/{userId}` к `User & Profile Service` для получения данных пользователя.
        *   `Support & Dispute Service` может запросить `REST API: GET /orders/{orderId}` к `Order & Project Service` для получения деталей связанного заказа.
        *   `Support & Dispute Service` может запросить `REST API: GET /messages/order/{orderId}/history` к `Messenger Service` для получения истории чата по заказу.
    *   **Response:** Сотрудник формулирует ответ.

7.  **Сотрудник службы поддержки -> Frontend Application (Админ-панель)**
    *   **Действие:** Сотрудник вводит ответ и отправляет его пользователю.
    *   **Payload:** Ответный текст.

8.  **Frontend Application (Админ-панель) -> API Gateway (Тип взаимодействия: REST API)**
    *   **Метод:** `PUT /api/v1/support/tickets/{ticketId}/reply`
    *   **Headers:** `Authorization: Bearer jwt-token-string` (токен сотрудника поддержки)
    *   **Payload:**
        ```json
        {
          "ticketId": "uuid-of-new-ticket",
          "replyText": "Ваш вопрос по оплате рассмотрен. Средства были начислены 28.06.2025 в 11:45...",
          "status": "resolved" // Статус меняется на решенный
        }
        ```

9.  **API Gateway -> Support & Dispute Service (Тип взаимодействия: REST API)**
    *   **Метод:** `PUT /support/tickets/{ticketId}/reply`
    *   **Payload:** То же, что из Frontend.
    *   **Response (Support & Dispute Service -> API Gateway):**
        ```json
        {
          "status": "success",
          "message": "Ответ отправлен, обращение помечено как решенное."
        }
        ```
    *   **Примечания:** Support & Dispute Service сохраняет ответ, меняет статус обращения.

10. **Support & Dispute Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `TicketUpdatedEvent` (или `TicketRepliedEvent`)
    *   **Payload:**
        ```json
        {
          "ticketId": "uuid-of-new-ticket",
          "userId": "uuid-of-user", // Пользователь, которому адресован ответ
          "status": "resolved",
          "timestamp": "2025-06-28T12:15:00Z"
        }
        ```
    *   **Примечания:** Публикуется для Notification Service и Analytics Service.

11. **RabbitMQ -> Notification Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `TicketUpdatedEvent`
    *   **Payload:** То же, что в п. 10.
    *   **Действие Notification Service:** Отправляет уведомление пользователю о получении ответа по обращению.

---

**Теперь сценарий с эскалацией (если пользователь не согласен):**

12. **Пользователь -> Frontend Application**
    *   **Действие:** Пользователь просматривает ответ поддержки и нажимает "Оспорить решение" / "Не согласен".
    *   **Payload:** Причина несогласия.

13. **Frontend Application -> API Gateway (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /api/v1/support/tickets/{ticketId}/dispute`
    *   **Headers:** `Authorization: Bearer jwt-token-string`
    *   **Payload:**
        ```json
        {
          "ticketId": "uuid-of-ticket",
          "reason": "Ответ не решил проблему, объяснение неверно."
        }
        ```

14. **API Gateway -> Support & Dispute Service (Тип взаимодействия: REST API)**
    *   **Метод:** `POST /support/tickets/{ticketId}/dispute`
    *   **Payload:** То же, что из Frontend, плюс `userId` из токена.
    *   **Response (Support & Dispute Service -> API Gateway):**
        ```json
        {
          "status": "disputed",
          "message": "Ваше оспаривание принято, обращение передано другому сотруднику."
        }
        ```
    *   **Примечания:** Support & Dispute Service регистрирует оспаривание, обновляет статус, и **назначает обращение другому сотруднику поддержки** (FR-SUP-6.4). Увеличивает счетчик повторных обращений.

15. **Support & Dispute Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `TicketDisputedEvent`
    *   **Payload:**
        ```json
        {
          "ticketId": "uuid-of-ticket",
          "userId": "uuid-of-user",
          "currentStatus": "disputed",
          "disputeCount": 1, // Или 2, если это второе оспаривание
          "timestamp": "2025-06-28T12:20:00Z"
        }
        ```
    *   **Примечания:** Публикуется для Notification Service, Analytics Service.

---

**Сценарий эскалации к Администратору (если оспаривание произошло 3+ раза):**

16. **Support & Dispute Service (Внутренняя логика)**
    *   **Действие:** Если `disputeCount` для обращения достигает 3 (или другого порога), Support & Dispute Service автоматически инициирует эскалацию.

17. **Support & Dispute Service -> RabbitMQ (Тип взаимодействия: Асинхронное событие - Публикация)**
    *   **Событие:** `TicketEscalatedEvent`
    *   **Payload:**
        ```json
        {
          "ticketId": "uuid-of-ticket",
          "userId": "uuid-of-user",
          "reason": "Эскалация: третье оспаривание решения поддержки.",
          "escalationTimestamp": "2025-06-28T12:30:00Z"
        }
        ```
    *   **Примечания:** Публикуется для Admin Service.

18. **RabbitMQ -> Admin Service (Тип взаимодействия: Асинхронное событие - Потребление)**
    *   **Событие:** `TicketEscalatedEvent`
    *   **Payload:** То же, что в п. 17.
    *   **Действие Admin Service:** Создает задачу для Администратора по рассмотрению эскалированного обращения. Администратор получает доступ к полной истории обращения и решений Support & Dispute Service.
        *   *(Внутреннее взаимодействие Admin Service):* `Admin Service` может запросить `REST API: GET /support/tickets/{ticketId}/full-history` к `Support & Dispute Service` для получения полного лога рассмотрения.
    *   **Результат:** Администратор принимает финальное решение по обращению.
