### **Текстовое Описание Потока Данных между Микросервисами**

Эта схема покажет, как данные, возникающие или изменяющиеся в одном микросервисе, распространяются и хранятся в базах данных других микросервисов, используя их API и брокер сообщений RabbitMQ.

#### **Ключевые Принципы:**

- **Владение данными (Data Ownership):** Каждый микросервис владеет своей собственной, отдельной базой данных и является единственным "источником правды" для своих сущностей. Никакой другой сервис не имеет прямого доступа к базе данных другого сервиса.
- **Публикация/Подписка:** Изменения в данных одного сервиса распространяются как события через RabbitMQ.
- **API-запросы:** Сервис может запрашивать актуальные данные (но не получать прямой доступ к БД) у другого сервиса через его REST API.

---

#### **I. Потоки данных по Источникам (Сервисы, которые инициируют изменения)**

1. **Authentication & Authorization Service (Auth Service)**
    - **Владеет базой данных, содержащей сущности:**UserAccount, UserSession, TwoFactorAuthSecret.
    - **Какие данные генерирует/изменяет:** Новые учетные записи, статус 2FA, статус email-подтверждения, активные сессии.
    - **Как данные взаимодействуют с другими сервисами:**
        - **Публикует (RabbitMQ):**UserRegisteredEvent (после регистрации, содержит UserID, Email, ProfileType), User2FAEnabledEvent (после включения 2FA, содержит UserID, Method).
        - **По запросу (REST API) предоставляет:** Валидность JWT (для API Gateway), статус аутентификации.
2. **User & Profile Service**
    - **Владеет базой данных, содержащей сущности:**UserProfile, PortfolioItem, Skill, WorkingStyle, Review.
    - **Какие данные генерирует/изменяет:** Детальные профили, портфолио, навыки, стили, полученные отзывы, агрегированный рейтинг пользователя.
    - **Как данные взаимодействуют с другими сервисами:**
        - **Потребляет (RabbitMQ):**UserRegisteredEvent (для создания базовой записи UserProfile после регистрации).
        - **Публикует (RabbitMQ):**ProfileUpdatedEvent (при изменении ключевых данных профиля), UserReviewAddedEvent (при добавлении нового отзыва, для обновления агрегированного рейтинга пользователя).
        - **По запросу (REST API) предоставляет:** Детальные данные профиля по UserID (UserProfile включая имя, аватар, рейтинг, описание) для Order & Project Service, Messenger Service, Notification Service, Support & Dispute Service, Admin Service (для отображения в UI, отчетах, уведомлениях).
3. **Roles & Permissions Service**
    - **Владеет базой данных, содержащей сущности:**Role, Permission, RolePermission, UserRole.
    - **Какие данные генерирует/изменяет:** Определения ролей и разрешений, назначенные роли пользователей.
    - **Как данные взаимодействуют с другими сервисами:**
        - **По запросу (REST API) предоставляет:** Данные о ролях и разрешениях (например, get_user_roles, check_permission) для Auth Service (для авторизации), Order & Project Service (для проверки прав), Admin Service (для управления).
4. **Order & Project Service**
    - **Владеет базой данных, содержащей сущности:**Order, OrderTag, Bid, OrderHistory.
    - **Какие данные генерирует/изменяет:** Новые заказы, отклики, статусы заказов, история изменений заказа, данные о выбранном фрилансере.
    - **Как данные взаимодействуют с другими сервисами:**
        - **Потребляет (RabbitMQ):**OrderPublicationFeeDebitedEvent (для изменения статуса заказа на PUBLISHED после оплаты).
        - **Публикует (RabbitMQ):**OrderPublishedEvent (при публикации заказа), OrderAcceptedForPayoutEvent (при принятии заказчиком работы, для инициации выплаты), OrderFullyCompletedEvent (после завершения выплаты).
        - **По запросу (REST API) предоставляет:** Детали заказа, отклики на заказ, статусы заказа для Payment Service (для деталей выплаты), Support & Dispute Service (контекст обращения), Admin Service, Analytics & Reporting Service.
5. **Messenger Service**
    - **Владеет базой данных, содержащей сущности:**Conversation, Message, Attachment.
    - **Какие данные генерирует/изменяет:** Текстовые сообщения, информация о вложениях в чате.
    - **Как данные взаимодействуют с другими сервисами:**
        - **Публикует (RabbitMQ):**NewMessageEvent (при отправке нового сообщения).
        - **По запросу (REST API) предоставляет:** Историю переписки для Support & Dispute Service.
6. **Notification Service**
    - **Владеет базой данных, содержащей сущности:**NotificationTemplate, NotificationLog, UserNotificationSetting.
    - **Какие данные генерирует/изменяет:** Шаблоны уведомлений, логи отправки, пользовательские настройки уведомлений.
    - **Как данные взаимодействуют с другими сервисами:**
        - **Потребляет (RabbitMQ):** Множество событий от других сервисов (UserRegisteredEvent, NewMessageEvent, OrderUpdatedEvent, PaymentProcessedEvent, TicketUpdatedEvent, SystemNotificationEvent и т.д.) для отправки уведомлений.
        - **По запросу (REST API):** Запрашивает данные UserProfile (UserID, Email, PhoneNumber) у User & Profile Service для отправки уведомлений.
7. **Payment Service**
    - **Владеет базой данных, содержащей сущности:**Account, Transaction.
    - **Какие данные генерирует/изменяет:** Балансы счетов, записи о всех финансовых транзакциях.
    - **Как данные взаимодействуют с другими сервисами:**
        - **Потребляет (RabbitMQ):**OrderAcceptedForPayoutEvent (для инициации выплаты по заказу).
        - **Публикует (RabbitMQ):**PaymentProcessedEvent (после успешной обработки транзакции: списания, начисления, комиссии).
        - **По запросу (REST API) предоставляет:** Данные о балансе и истории транзакций для Frontend (через API Gateway), Admin Service.
8. **Support & Dispute Service**
    - **Владеет базой данных, содержащей сущности:**Ticket, TicketMessage, TicketLog, DisputeReason.
    - **Какие данные генерирует/изменяет:** Обращения пользователей, сообщения в тредах, историю изменений обращений, статус оспариваний/эскалаций.
    - **Как данные взаимодействуют с другими сервисами:**
        - **Публикует (RabbitMQ):**TicketCreatedEvent, TicketUpdatedEvent, TicketDisputedEvent, TicketEscalatedEvent.
        - **По запросу (REST API) предоставляет:** Детали обращения (Ticket, TicketMessage, TicketLog) для Admin Service.
9. **Analytics & Reporting Service**
    - **Владеет базой данных, содержащей сущности:**AggregatedMetric, RawEventLog, ReportDefinition.
    - **Какие данные генерирует/изменяет:** Агрегированные метрики, хранит сырые логи событий, определения отчетов.
    - **Как данные взаимодействуют с другими сервисами:**
        - **Потребляет (RabbitMQ):** Большинство событий от других сервисов (UserRegisteredEvent, OrderPublishedEvent, PaymentProcessedEvent, NewMessageEvent, TicketCreatedEvent и т.д.) для сбора и обработки метрик.
        - **По запросу (REST API) предоставляет:** Агрегированные данные и отчеты для Admin Service (для дашбордов).
10. **Admin Service**
    - **Владеет базой данных, содержащей сущности:**PlatformSetting, ModerationLog, StaffMember, ReferenceData.
    - **Какие данные генерирует/изменяет:** Настройки платформы (комиссии, стоимость публикации), записи о модерационных действиях, данные о сотрудниках поддержки, справочные данные.
    - **Как данные взаимодействуют с другими сервисами:**
        - **Потребляет (RabbitMQ):**TicketEscalatedEvent (для обработки эскалированных обращений).
        - **Публикует (RabbitMQ):**SystemNotificationEvent (при изменении важных настроек или для системных уведомлений).
        - **По запросу (REST API) изменяет/запрашивает данные в других сервисах:**
            - User & Profile Service: Изменение статуса пользователя (блокировка/удаление).
            - Order & Project Service: Просмотр/модерация заказов.
            - Payment Service: Инициация ручных возвратов/корректировок.
            - Support & Dispute Service: Управление обращениями, переназначение.
            - Analytics & Reporting Service: Запрос на генерацию отчетов.
### **Пошаговое Руководство по Созданию Диаграммы Потока Данных (DFD) / Архитектуры Данных в Draw.io**

**Цель:** Визуализировать, как данные создаются, изменяются, хранятся и распространяются между базами данных микросервисов через API и RabbitMQ.**Инструмент:** Draw.io (diagrams.net).**Шаг 0: Подготовка Draw.io**

1. Убедись, что ты находишься в том же файле Draw.io.
2. Добавь новую страницу (кликни +).
3. Переименуй её: DFD: Data Flow Across Microservices.
4. Убедись, что активны библиотеки: General, UML (для компонентов), Arrows. Возможно, Misc для символа БД.

---

#### **Шаг 1: Размещение Микросервисов и их Баз Данных**

На этой диаграмме мы покажем каждый микросервис вместе с его _собственной_ базой данных.

1. **Размещение RabbitMQ:**
    - Используй элемент **"Component"** из UML библиотеки.
    - Назови его: RabbitMQ (Message Broker).
    - **Размещение:** Помести его в центре холста, так как он будет центральной точкой для асинхронных потоков.
2. **Размещение Микросервисов и их Баз Данных:**
    - Для каждого из 10 микросервисов мы создадим пару: **Компонент Сервиса** и **Символ Базы Данных**.
    - В библиотеке UML, используй элемент **"Component"** для каждого сервиса.
    - В библиотеке Misc или Networking (или AWS -> Database или GCP -> Database), найди символ **"Database"** (обычно цилиндр) или просто используй Rectangle с названием DB.
    - **Для каждого из 10 микросервисов (Auth Service, User & Profile Service, ..., Admin Service):**
        - Перетащи элемент **"Component"** и назови его (например, Authentication & Authorization Service).
        - Рядом (обычно прямо под сервисом или рядом с ним), перетащи элемент **"Database"** (цилиндр) и назови его, например: Auth DB (UserAccount, Sessions). Или просто Auth DB.
        - **Визуальная связь:** Можно соединить Компонент Сервиса со своей БД короткой сплошной стрелкой (например, сверху вниз), чтобы показать, что сервис читает/пишет в эту БД. Подпись: Read/Write.
        - **Размещение:** Располагай эти пары "Сервис + БД" вокруг RabbitMQ таким образом, чтобы было удобно рисовать потоки данных.

---

#### **Шаг 2: Визуализация Потоков Данных (Стрелки)**

Мы будем использовать различные стили стрелок для разных типов потоков.

1. **Поток Данных от API Gateway к Сервисам (для инициации действий):**
    - Мы не показываем API Gateway и Frontend напрямую на этой диаграмме, так как фокус на данных _между_ микросервисами. Но помним, что большинство потоков данных _начинаются_ с API-вызовов.
    - Поток данных от внешних систем/пользователей через API Gateway к соответствующим сервисам (где данные сначала попадают):
        - Например, от "внешнего мира" (необязательно рисовать, можно подразумевать) к Auth Service (POST /register), к Order & Project Service (POST /orders/create).
        - Используй **сплошные стрелки** к соответствующим сервисам. Подпись: REST API Request Data.
2. **Поток Данных: REST API Запросы между Сервисами (для чтения данных)**
    - Это синхронные запросы, где один сервис _запрашивает_ данные у другого.
    - Используй **сплошные стрелки** от сервиса-клиента к сервису-поставщику.
    - _Примеры:_
        - Auth Service -> Roles & Permissions Service: Request: User Roles
        - Order & Project Service -> User & Profile Service: Request: Customer/Freelancer Profile
        - Notification Service -> User & Profile Service: Request: Contact Info
        - Support & Dispute Service -> Order & Project Service: Request: Order Context
        - Admin Service -> Analytics & Reporting Service: Request: Reports Data
    - _Подпись:_REST API: Request Data [Сущность] (например, REST API: Request: User Profile Data)
3. **Поток Данных: Асинхронные События через RabbitMQ (для записи/обновления данных)**
    - Это основной способ, которым данные "движутся" между базами данных разных сервисов, без прямого доступа.
    - Используй **пунктирные стрелки** для событий.
    - **От Сервиса-источника -> RabbitMQ (Публикация События):**
        - Auth Service -> RabbitMQ: Event: UserRegistered, Event: User2FAEnabled
        - User & Profile Service -> RabbitMQ: Event: ProfileUpdated, Event: UserReviewAdded
        - Order & Project Service -> RabbitMQ: Event: OrderPublished, Event: OrderAcceptedForPayout, Event: OrderFullyCompleted
        - Messenger Service -> RabbitMQ: Event: NewMessage
        - Payment Service -> RabbitMQ: Event: PaymentProcessed
        - Support & Dispute Service -> RabbitMQ: Event: TicketUpdated, Event: TicketEscalated
        - Admin Service -> RabbitMQ: Event: SystemSettingUpdated
        - _Подпись:_Publishes: [Название события]
    - **От RabbitMQ -> Сервису-получателю (Потребление События для обновления своей БД):**
        - RabbitMQ -> User & Profile Service: Consumes: UserRegistered Event (для создания профиля).
        - RabbitMQ -> Order & Project Service: Consumes: OrderPublicationFeeDebited Event (для обновления статуса заказа).
        - RabbitMQ -> Payment Service: Consumes: OrderAcceptedForPayout Event (для инициации транзакции).
        - RabbitMQ -> Notification Service: Consumes: All Notification Events (использует данные из этих событий для отправки уведомлений).
        - RabbitMQ -> Analytics & Reporting Service: Consumes: All Business Events (для агрегации метрик).
        - RabbitMQ -> Admin Service: Consumes: TicketEscalated Event (для реакции).
        - _Подпись:_Consumes: [Название события]

#### **Шаг 3: Финальная Проверка и Оформление**

- Убедись, что для каждой пары "Сервис + его БД" есть четкое владение.
- Все стрелки понятны: сплошные для REST (запрос данных), пунктирные для событий (поток данных для асинхронного обновления).
- Минимизируй пересечения.
- Добавь заголовок: Диаграмма Потока Данных в Микросервисной Архитектуре.